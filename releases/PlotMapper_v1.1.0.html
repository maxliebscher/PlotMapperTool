<!DOCTYPE html>

<html lang="en"><head>
<meta charset="utf-8"/>
<title>PlotMapper ‚Äì Story Path Mapping Tool</title>
<meta content="PlotMapper is a lightweight tool to visually plan your story on a map. Runs in any browser ‚Äì made by Max Liebscher." name="description"/>
<meta content="Max Liebscher" name="author"/>
<meta content="PlotMapper ‚Äì Story Planning Tool" property="og:title"/>
<meta content="Visually plan routes, characters and events on a map. Open-source and browser-based." property="og:description"/>
<meta content="website" property="og:type"/>
<meta content="https://maxliebscher.com/tools/plotmapper/preview.png" property="og:image"/>
<meta content="https://maxliebscher.com/tools/plotmapper" property="og:url"/>
<style>
 body{margin:0;background:#333;font-family:sans-serif;overflow:hidden}
 #canvas{position:absolute;top:0;left:0;touch-action:none;z-index:0;background:#111;cursor:grab}
 .point{position:absolute;width:32px;height:32px;border-radius:50%;background:#fff;display:flex;align-items:center;justify-content:center;font-weight:700;color:#000;transform:translate(-50%,-50%);border:2px solid #000;user-select:none;z-index:10}
 .label{position:absolute;left:50%;top:100%;transform:translate(-50%,4px);background:rgba(0,0,0,.6);color:#fff;padding:0 4px;border-radius:4px;font-size:11px;white-space: normal;pointer-events:none}
 .mid{position:absolute;width:16px;height:16px;border-radius:50%;background:rgba(160,160,160,.8);transform:translate(-50%,-50%);cursor:pointer;z-index:5}
 .btn{position:absolute;right:-6px;top:-6px;width:14px;height:14px;font-size:11px;border-radius:50%;background:#444;color:#fff;display:none;align-items:center;justify-content:center;cursor:pointer}
 .menu{position:absolute;background:#222;color:#fff;padding:6px 8px 6px 8px;border-radius:6px;font-size:13px;display:flex;flex-direction:column;gap:4px;z-index:30;align-items:flex-start;min-width:120px}
 .menu button{background:#444;border:none;color:#fff;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;text-align:left;width:100%;}
 .menu button:hover{background:#666}
 .menu b{margin-bottom:2px;}
 #ui{position:fixed;top:8px;left:8px;background:rgba(0,0,0,.85);color:#fff;padding:10px;border-radius:8px;z-index:50;font-size:14px;line-height:1.4}
 #ui input[type=range]{width:120px}
 #ui label{user-select:none;margin-right:4px}
 #ui button{margin:2px;font-size:13px}
 #kapitelHinweis{color:#8df;margin-left:8px}
 .icon {font-size:16px;margin-right:2px;}
 .hide{display:none!important;}

 .label.note {
    max-width: 320px;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: 1.2;
    padding: 4px 8px;
    background: rgba(0,0,0,0.6);
    border-radius: 4px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    font-size: 0.7em;
  }
  
  .dauer {
    position:absolute;
    font-size:11px;
    background:rgba(0,0,0,0.6);
    color:#fff;
    padding:0 4px;
    border-radius:4px;
    white-space:nowrap;
    pointer-events:none;
    z-index:15;
  }
.dauer::before {
  content: '‚åõ';
  margin-right: 4px;
}
</style>
<script>
function addRoutePoint(px, py) {
    const r = imgRect();
    const nx = (px - r.x) / r.w;
    const ny = (py - r.y) / r.h;
    createPoint({ x: nx, y: ny, label: "", note: "", ptype: "route" });
    updateNumbers();
    draw();
}
function ensureChildren(p){
  if(p.noteEl && p.noteEl.parentNode !== p.el){ p.el.appendChild(p.noteEl); }
  if(p.dauerEl && p.dauerEl.parentNode !== p.el){ p.el.appendChild(p.dauerEl); }
}
function setStackVars(p){
  const el = p.el;
  const lblVisible  = (p.lbl && p.lbl.style.display !== 'none' && (p.label||'').trim()!=='');
  const noteVisible = (p.noteEl && p.noteEl.style.display !== 'none');
  const lblH  = lblVisible  ? p.lbl.offsetHeight   : 0;
  const noteH = noteVisible ? p.noteEl.offsetHeight: 0;
  el.style.setProperty('--lbl-h',  lblH  + 'px');
  el.style.setProperty('--note-h', noteH + 'px');
}
function posNote(p){
  if(!p.noteEl) return;
  if(p.noteEl.parentNode === p.el){
    // absvar: CSS erledigt das Stacking
    p.noteEl.style.left = '50%';
    p.noteEl.style.top  = '';
    p.noteEl.style.transform = 'translateX(-50%)';
  }else{
    // Fallback (grid/flex): globale Pixelposition
    const r = imgRect();
    p.noteEl.style.left = (r.x + p.x * r.w + 8) + 'px';
    p.noteEl.style.top  = (r.y + p.y * r.h + 8) + 'px';
    p.noteEl.style.transform = '';
  }
}
function posDauer(p){
  if(!p.dauerEl) return;
  if(p.dauerEl.parentNode === p.el){
    p.dauerEl.style.left = '50%';
    p.dauerEl.style.top  = '';
    p.dauerEl.style.transform = 'translateX(-50%)';
  }else{
    const r = imgRect();
    p.dauerEl.style.left = (r.x + p.x * r.w + 8) + 'px';
    p.dauerEl.style.top  = (r.y + p.y * r.h + 24) + 'px';
    p.dauerEl.style.transform = '';
  }
}
</script>
<style>
  
  .simple-mode #ui span[data-i18n-key="POINT_TYPES_FILTER_7"] {
    display: none !important;
  }
  
  .simple-mode #ui label[for^="filter-"],
  .simple-mode #ui input[id^="filter-"],
  
  .simple-mode #ui input#filterRoute,
  .simple-mode #ui input#filterRoute + span {
    display: none !important;
  }
  
  .simple-mode #ui label.advanced {
    display: none !important;
  }
    .simple-mode .point:not(.route) {
    display: none !important;
  }
</style>
<style id="pm-styles-clean">
/* Clean absvar: Label (Kapitel) ‚Üí Notiz ‚Üí Dauer */
.point {
  --gap: 3px;    /* globaler Abstand */
  --lbl-h: 0px;         /* JS setzt echte H√∂he */
  --note-h: 0px;        /* JS setzt echte H√∂he */
}

/* Kapitel-Label (nicht .label.note) */
.point .label:not(.note), .point > .label {
  position:absolute; left:50%; transform:translateX(-50%);
  top: calc(100% + var(--gap));
  max-width:240px;
  white-space:normal; word-break:break-word; line-height:1.2; padding:2px 6px;
}

/* Notiz */
.point .note {
  position:absolute; left:50%; transform:translateX(-50%);
  top: calc(100% + var(--gap) + var(--lbl-h) + var(--gap));
  max-width:320px; line-height:1.25; padding:4px 8px;
  white-space:pre-wrap; word-wrap:break-word;
}

/* Dauer */
.point .dauer {
  position:absolute; left:50%; transform:translateX(-50%);
  top: calc(100% + var(--gap) + var(--lbl-h) + var(--gap) + var(--note-h) + var(--gap));
}
.dauer::before { content:'\231B'; margin-right:4px; }

/* --- ABSVAR Breite/√úberlauf fix --- */
.point{ overflow: visible; }  /* darf √ºber 32px hinausragen */

.point .label,
.point .note,
.point .dauer{
  width: max-content;        /* eigene Breite, nicht auf 32px schrumpfen */
}

@supports not (width: max-content){
  /* Fallback f√ºr alte Browser */
  .point .label,
  .point .note,
  .point .dauer{ display:inline-block; }
}

</style><style id="pm-fontscale-css">
:root {
  --font-scale: 1; /* 1.00 = 100% */
}
/* Map-Labels */
.point .label:not(.note), .point > .label {
  font-size: calc(11px * var(--font-scale)) !important;
  line-height: calc(1.2 * var(--font-scale));
}

.point .note {
  font-size: calc(9px * var(--font-scale)) !important;   /* vorher 0.em war ein Tippfehler */
  line-height: calc(1.25 * var(--font-scale));
}

.point .dauer {
  font-size: calc(10px * var(--font-scale)) !important;
  line-height: calc(1.2 * var(--font-scale));
}

</style></head>
<body>
<div id="ui"><input accept="image/*" id="imgInp" type="file"/><button data-i18n-key="LANG_TOGGLE" id="langToggle">DE</button><button id="modeToggle"><span data-i18n-key="TOGGLE_MODE_1">Toggle Mode</span></button>
<br/>
<label><input id="kapitelMode" type="checkbox"/><span data-i18n-key="CHAPTER_NUMBERING_2">Chapter Numbering</span></label>
<span id="kapitelHinweis"></span><br/>
<label><input checked="" id="chkLabels" type="checkbox"/><span data-i18n-key="CHAPTER_3">Chapter</span></label>
<label><input checked="" id="chkNotes" type="checkbox"/><span data-i18n-key="SHOW_NOTES_4">Show Notes</span></label>
<label><input checked="" id="chkLines" type="checkbox"/><span data-i18n-key="LINES_5">Lines</span></label>
<label><input checked="" id="chkEdit" type="checkbox"/><span data-i18n-key="EDIT_BUTTONS_6">Edit‚ÄëButtons</span></label><br/>
<span data-i18n-key="POINT_TYPES_FILTER_7">Point Types Filter</span>
<label><input checked="" id="filterRoute" type="checkbox"/><span data-i18n-key="ROUTE_8">Route</span></label>
<label class="advanced advanced"><input checked="" id="filterPlace" type="checkbox"/><span data-i18n-key="PLACE_9">Place</span></label>
<label class="advanced advanced"><input checked="" id="filterChar" type="checkbox"/><span data-i18n-key="CHARACTER_10">Character</span></label>
<label class="advanced advanced"><input checked="" id="filterEvent" type="checkbox"/><span data-i18n-key="EVENT_11">Event</span></label>
<label class="advanced advanced"><input checked="" id="filterItem" type="checkbox"/><span data-i18n-key="ITEM_12">Item</span></label>
<label class="advanced advanced"><input checked="" id="chkDauer" type="checkbox"/><span data-i18n-key="_SHOW_DURATION_13">‚åõ Show Duration</span></label><br/><span data-i18n-key="ZOOM_14">Zoom</span><input id="zoom" max="5" min="1" step="0.01" type="range" value="1"/><br/><span data-i18n-key="OPACITY_15">Opacity</span><input id="opacity" max="1" min="0.1" step="0.01" type="range" value="1"/><br/>
<button id="undo"><span data-i18n-key="_UNDO_16">‚Ü∫ Undo</span></button><button id="redo"><span data-i18n-key="_REDO_17">‚Üª Redo</span></button>
<button id="exportMd"><span data-i18n-key="EXPORT_MD_18">Export¬†MD</span></button><button id="importMd"><span data-i18n-key="IMPORT_MD_19">Import¬†MD</span></button>
<button id="exportImg"><span data-i18n-key="PNG_20">PNG</span></button><button id="clearAll"><span data-i18n-key="CLEAR_ALL_21">Clear All</span></button>
</div>
<canvas id="canvas"></canvas>
<script>
let mdExportCount = 1;
let imgExportCount = 1;

const translations = {
  de: {
    pointTypes: {
      route: { icon: 'üó∫Ô∏è', name: 'Routen-Punkt', label: 'Kapitel', filter: 'filterRoute' },
      place: { icon: 'üìç', name: 'Ort',           label: 'Ort',     filter: 'filterPlace' },
      char:  { icon: 'üë§', name: 'Charakter',     label: 'Charakter', filter: 'filterChar' },
      event: { icon: '‚òÖ', name: 'Event',         label: 'Event',   filter: 'filterEvent' },
      item:  { icon: 'üîë', name: 'Item',          label: 'Item',    filter: 'filterItem' }
    }
  },
  en: {
    pointTypes: {
      route: { icon: 'üó∫Ô∏è', name: 'Route Point',  label: 'Chapter', filter: 'filterRoute' },
      place: { icon: 'üìç', name: 'Place',        label: 'Place',   filter: 'filterPlace' },
      char:  { icon: 'üë§', name: 'Character',    label: 'Character', filter: 'filterChar' },
      event: { icon: '‚òÖ', name: 'Event',        label: 'Event',   filter: 'filterEvent' },
      item:  { icon: 'üîë', name: 'Item',         label: 'Item',    filter: 'filterItem' }
    }
  }
};

function getLocale() {
  const urlLang = new URLSearchParams(window.location.search).get('lang');
  if (urlLang && translations[urlLang]) return urlLang;
  const docLang = document.documentElement.lang;
  if (translations[docLang]) return docLang;
  return navigator.language.startsWith('de') ? 'de' : 'en';
}

const locale = getLocale();
const BASE_POINT_TYPES = ['route', 'place', 'char', 'event', 'item'];
const POINT_TYPES = BASE_POINT_TYPES.map(type => {
  const t = translations[locale].pointTypes[type];
  return {
    type:   type,
    icon:   t.icon,
    name:   t.name,
    label:  t.label,
    filter: t.filter
  };
});

function getIcon(ptype) {
    const pt=POINT_TYPES.find(t=>t.type===ptype); return pt?pt.icon:'';
}
function getTypeMeta(ptype) {
    return POINT_TYPES.find(t=>t.type===ptype) || POINT_TYPES[0];
}
function isVisibleType(ptype){
    let meta=getTypeMeta(ptype);
    let box=document.getElementById(meta.filter);
    return box && box.checked;
}

const cvs=document.getElementById('canvas'),ctx=cvs.getContext('2d');
let img=new Image(),imgLoaded=false,zoomValue=1,opacityValue=1,panX=0,panY=0;
let draggingMap=false,startPan;
const points=[],midEls=[];
let showLines=true,showLabels=true,showEdit=true,showNotes=true;
let showDauer = true;
const undoStack=[],redoStack=[];
let kapitelMode=false, kapitelStartNum=1;

function push(){undoStack.push(JSON.stringify(points.map(stripElm)));redoStack.length=0}
function stripElm(p) {
  const { el, txt, lbl, btn, noteEl, dauerEl, icon, ...rest } = p;
  return rest;
}
function restore(arr){clearDOM();points.length=0;arr.forEach(d=>createPoint({...d},true));updateNumbers();draw();}
function clearDOM() {
  points.forEach(p => {
    p.el.remove();
    p.noteEl  && p.noteEl.remove();
    p.dauerEl && p.dauerEl.remove(); 
    
    p.note    = null;
    p.dauer   = null;
    p.noteEl  = null;
    p.dauerEl = null;
  });
  midEls.forEach(m => m.remove());
  midEls.length = 0;
}

function resize(){cvs.width=innerWidth;cvs.height=innerHeight;draw();updateDOM()}
window.addEventListener('resize',resize);

function imgRect(){
    const r=Math.min(cvs.width/img.width,cvs.height/img.height)*zoomValue;
    const w=img.width*r,h=img.height*r;
    const x=(cvs.width-w)/2+panX,y=(cvs.height-h)/2+panY;
    return{x,y,w,h}
}

function draw(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  if(!imgLoaded) return;
  const r = imgRect();
  ctx.globalAlpha = opacityValue;
  ctx.drawImage(img, r.x, r.y, r.w, r.h);
  ctx.globalAlpha = 1;

  if(showLines) {
    drawLines();
  } else {
    midEls.forEach(m => m.style.display = 'none');
  }

  points.forEach(p => {
    if (p.noteEl)  posNote(p);
    if (p.dauerEl) posDauer(p);
  });
}

function drawLines(){
    midEls.forEach(m=>m.remove());midEls.length=0;
    
    const routePts = points.filter(p => (p.ptype||'route') === 'route' && isVisibleType('route'));
    if(routePts.length<2)return;
    const r=imgRect();
    ctx.lineWidth=4;ctx.strokeStyle='rgba(0,0,0,.5)';ctx.beginPath();
    routePts.forEach((p,i)=>{const px=r.x+p.x*r.w,py=r.y+p.y*r.h;i ? ctx.lineTo(px,py):ctx.moveTo(px,py)});
    ctx.stroke();
    ctx.strokeStyle='red';ctx.lineWidth=2;ctx.beginPath();
    routePts.forEach((p,i)=>{const px=r.x+p.x*r.w,py=r.y+p.y*r.h;i ? ctx.lineTo(px,py):ctx.moveTo(px,py)});
    ctx.stroke();
    routePts.forEach((p,i)=>{if(i)addMid(routePts[i-1],p)});
}

function addMid(a,b){
  if ((a.ptype||'route') !== 'route' || (b.ptype||'route') !== 'route') return;
  const r = imgRect();
  const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
  const el = document.createElement('div');el.className = 'mid';document.body.appendChild(el);
  midEls.push(el);pos(el, mx, my);
  el.onclick = () => {push();
    let idxA = points.indexOf(a), idxB = points.indexOf(b);
    let idx = Math.max(idxA, idxB);
    let neu = { x: mx, y: my, label: '', note: '', ptype: 'route', dauer: '' };
    points.splice(idx, 0, neu);
    createPointMid(neu, idx);
    updateNumbers(); draw();
  }
}
function createPointMid(d, idx){
    const { x, y, label='', note='', ptype='route', dauer='', helper=false } = d;
    const el=document.createElement('div'); el.className = 'point';
  el.classList.add(ptype);
    const icon=document.createElement('span');icon.className='icon';
    if(ptype!=='route') icon.textContent=getIcon(ptype);
    el.appendChild(icon);
    const txt=document.createElement('span');el.appendChild(txt);
    const btn=document.createElement('div');btn.className='btn';btn.textContent='‚â°';el.appendChild(btn);
    const lbl=document.createElement('div');lbl.className='label';lbl.textContent=label;el.appendChild(lbl);
    const p={x,y,label,note,ptype,dauer,helper,el,txt,lbl,btn,icon};points[idx]=p;
    document.body.appendChild(el);pos(el,x,y);updateVis();
    btn.onclick=e=>{e.stopPropagation();showMenu(e.clientX,e.clientY,p)};
    let dragId=null,startD;
    el.onpointerdown=e=>{if(e.target===btn)return;dragId=e.pointerId;startD={x:e.clientX,y:e.clientY,px:p.x,py:p.y};el.setPointerCapture(e.pointerId)};
    el.onpointermove = e => {
  if (e.pointerId !== dragId) return;
  const r = imgRect();
  p.x = startD.px + (e.clientX - startD.x) / r.w;
  p.y = startD.py + (e.clientY - startD.y) / r.h;
  pos(el, p.x, p.y);
  draw();
  updateDOM();
  if (p.noteEl)  posNote(p);
  if (p.dauerEl) posDauer(p);
};
    el.onpointerup=e=>{if(e.pointerId===dragId){dragId=null;push()}};
}

function createPoint(d,fromLoad=false){
    const {x,y,label='',note='',ptype='route',dauer='',helper=false}=d;
    const el=document.createElement('div'); el.className = 'point';
  el.classList.add(ptype);
    const icon=document.createElement('span');icon.className='icon';
    if(ptype!=='route') icon.textContent=getIcon(ptype);
    el.appendChild(icon);
    const txt=document.createElement('span');el.appendChild(txt);
    const btn=document.createElement('div');btn.className='btn';btn.textContent='‚â°';el.appendChild(btn);
    const lbl=document.createElement('div');lbl.className='label';lbl.textContent=label;el.appendChild(lbl);
    const p={x,y,label,note,ptype,dauer,helper,el,txt,lbl,btn,icon};points.push(p);
    document.body.appendChild(el);pos(el,x,y);updateVis();
    btn.onclick=e=>{e.stopPropagation();showMenu(e.clientX,e.clientY,p)};
    let dragId=null,startD;
    el.onpointerdown=e=>{if(e.target===btn)return;dragId=e.pointerId;startD={x:e.clientX,y:e.clientY,px:p.x,py:p.y};el.setPointerCapture(e.pointerId)};
el.onpointermove = e => {
  if (e.pointerId !== dragId) return;
  const r = imgRect();
  p.x = startD.px + (e.clientX - startD.x) / r.w;
  p.y = startD.py + (e.clientY - startD.y) / r.h;
  pos(el, p.x, p.y);
  draw();
  updateDOM();
  if (p.noteEl)  posNote(p);
  if (p.dauerEl) posDauer(p);
};
    el.onpointerup=e=>{if(e.pointerId===dragId){dragId=null;push()}};

el.ontouchstart = function(e){
  if(e.target===btn)return;
  const touch = e.touches[0];
  dragId = "touch";
  startD = {x: touch.clientX, y: touch.clientY, px: p.x, py: p.y};
  e.preventDefault();
};
el.ontouchmove = function(e){
  if(dragId !== "touch") return;
  const touch = e.touches[0];
  const r = imgRect();
  p.x = startD.px + (touch.clientX - startD.x)/r.w;
  p.y = startD.py + (touch.clientY - startD.y)/r.h;
  pos(el, p.x, p.y);
  draw();
  updateDOM();
  if(p.noteEl) posNote(p);
  if (p.dauerEl) posDauer(p);
    if (p.dauerEl) {
      const r2 = imgRect();
      p.dauerEl.style.left = (r2.x + p.x * r2.w) + 'px';
      p.dauerEl.style.top  = (r2.y + p.y * r2.h + 38) + 'px';
    }
  e.preventDefault();
};
el.ontouchend = function(e){
    
    if (e.target === btn) return;
    
    if (dragId === "touch") {
        dragId = null;
        push();
        e.preventDefault();
    }
};

    if(!fromLoad)push();
}
function pos(el,nx,ny){const r=imgRect();el.style.left=r.x+nx*r.w+'px';el.style.top=r.y+ny*r.h+'px'}

function posNote(p){
  if(!p.noteEl) return;
  if(p.noteEl.parentNode === p.el){
    // absvar: CSS erledigt das Stacking
    p.noteEl.style.left = '50%';
    p.noteEl.style.top  = '';
    p.noteEl.style.transform = 'translateX(-50%)';
  }else{
    // Fallback (grid/flex): globale Pixelposition
    const r = imgRect();
    p.noteEl.style.left = (r.x + p.x * r.w + 8) + 'px';
    p.noteEl.style.top  = (r.y + p.y * r.h + 8) + 'px';
    p.noteEl.style.transform = '';
  }
}

function posDauer(p){
  if(!p.dauerEl) return;
  if(p.dauerEl.parentNode === p.el){
    p.dauerEl.style.left = '50%';
    p.dauerEl.style.top  = '';
    p.dauerEl.style.transform = 'translateX(-50%)';
  }else{
    const r = imgRect();
    p.dauerEl.style.left = (r.x + p.x * r.w + 8) + 'px';
    p.dauerEl.style.top  = (r.y + p.y * r.h + 24) + 'px';
    p.dauerEl.style.transform = '';
  }
}

function updateVis() {
  const isFocus = document.documentElement.classList.contains('simple-mode');
  points.forEach(p => {
    
    if (p.note) {
      if (!p.noteEl) {
        p.noteEl = document.createElement('div');
        p.noteEl.className = 'label note';
        p.el.appendChild(p.noteEl);
      }
      p.noteEl.textContent = p.note;
    }
    
    if (p.dauer) {
      if (!p.dauerEl) {
        p.dauerEl = document.createElement('div');
        p.dauerEl.className = 'dauer';
        p.el.appendChild(p.dauerEl);
      }
      p.dauerEl.textContent = p.dauer;
    }
    
    if ((isFocus && (p.ptype||'route')!=='route') || !isVisibleType(p.ptype||'route')) {
      p.el.classList.add('hide');
      p.noteEl  && p.noteEl.classList.add('hide');
      p.dauerEl && (p.dauerEl.style.display = 'none');
      return;
    }
    p.el.classList.remove('hide');
if (p.noteEl)  p.noteEl.style.display  = (showNotes && p.note)  ? 'block' : 'none';
if (p.dauerEl) p.dauerEl.style.display = (showDauer && p.dauer) ? 'block' : 'none';
    
    p.lbl.style.display = showLabels && p.label ? 'block' : 'none';
    p.btn.style.display = showEdit               ? 'flex'  : 'none';
    p.icon.textContent  = p.ptype!=='route'      ? getIcon(p.ptype) : '';
    
    p.noteEl  && posNote(p);
    p.dauerEl && posDauer(p);
  });
}

function updateNumbers() {
    let cnt = 1;
    points.forEach((p,i)=>{
      if ((p.ptype||'route') === 'route' && isVisibleType('route')) {
        if (p.helper) {
          p.txt.textContent = "";
          p.route_step = "";
          p.el && p.el.classList && p.el.classList.add('helper');
        } else {
          p.txt.textContent = kapitelMode ? (kapitelStartNum + cnt - 1) : cnt;
          p.route_step = cnt;
          p.el && p.el.classList && p.el.classList.remove('helper');
          cnt++;
        }
      } else {
        p.txt.textContent = "";
        p.route_step = "";
        p.el && p.el.classList && p.el.classList.remove('helper');
      }
    });
    const hint = document.getElementById('kapitelHinweis');
    if (hint) hint.textContent = kapitelMode ? `Chapter mode active (Start: ${kapitelStartNum})` : "";
}

function updateDOM() {
  points.forEach(p => {
    pos(p.el, p.x, p.y);
    ensureChildren(p);
    setStackVars(p);
    if (p.noteEl)  posNote(p);
    if (p.dauerEl) posDauer(p);
  });
  updateVis();
}

document.getElementById('imgInp').onchange = e => {
    const f = e.target.files[0]; if (!f) return;
    img.src = URL.createObjectURL(f);
    img.onload = () => { imgLoaded=true; zoomValue=1; opacityValue=1; panX=panY=0; document.getElementById('zoom').value=1; document.getElementById('opacity').value=1; resize(); }
};
document.getElementById('zoom').oninput = e => { zoomValue = parseFloat(e.target.value); draw(); updateDOM(); };
document.getElementById('opacity').oninput = e => { opacityValue = parseFloat(e.target.value); draw(); };
document.getElementById('chkLines').onchange = e => { showLines = e.target.checked; draw(); };
document.getElementById('chkLabels').onchange = e => { showLabels = e.target.checked; updateVis(); };
document.getElementById('chkNotes').onchange = e => { showNotes = e.target.checked; updateVis(); };
    document.getElementById('chkEdit').onchange = e => {
  showEdit = e.target.checked;
  updateVis();
  document.querySelectorAll('.mid').forEach(m =>
    m.style.display = showEdit ? 'block' : 'none'
  );
};
    document.getElementById('chkDauer').onchange = e => { showDauer = e.target.checked; updateVis(); };
document.getElementById('undo').onclick = () => { if(undoStack.length){ redoStack.push(JSON.stringify(points.map(stripElm))); restore(JSON.parse(undoStack.pop())); }};
document.getElementById('redo').onclick = () => { if(redoStack.length){ undoStack.push(JSON.stringify(points.map(stripElm))); restore(JSON.parse(redoStack.pop())); }};
document.getElementById('clearAll').onclick = () => { if(confirm('Delete all points?')){ push(); clearDOM(); points.length=0; draw(); updateNumbers(); }};
document.getElementById('kapitelMode').onchange = e => {
   kapitelMode = e.target.checked;
   if (kapitelMode) {
       let neu = prompt("Start at which chapter number?", kapitelStartNum);
       if (!neu || isNaN(parseInt(neu))) neu = kapitelStartNum;
       kapitelStartNum = parseInt(neu);
   }
   updateNumbers(); draw();
};

['filterRoute','filterPlace','filterChar','filterEvent','filterItem'].forEach(id=>{
  document.getElementById(id).onchange=()=>{updateVis();draw();}
});

cvs.onpointerdown = e => {
    if(!imgLoaded) return;
    if([...document.elementsFromPoint(e.clientX,e.clientY)].some(el=>el.className && el.className.includes('point'))) return;
    draggingMap=true; startPan={x:e.clientX,y:e.clientY,px:panX,py:panY}; cvs.setPointerCapture(e.pointerId);
};
cvs.onpointermove = e => { if(!draggingMap) return; panX=startPan.px+(e.clientX-startPan.x); panY=startPan.py+(e.clientY-startPan.y); draw(); updateDOM(); };
cvs.onpointerup = e => draggingMap=false;

cvs.addEventListener("touchstart", handleTouchStart, { passive: false });
cvs.addEventListener("touchmove", handleTouchMove, { passive: false });
cvs.addEventListener("touchend", handleTouchEnd, { passive: false });

function getTouchPos(evt) {
  const rect = cvs.getBoundingClientRect();
  const touch = evt.touches[0] || evt.changedTouches[0];
  return {
    x: touch.clientX,
    y: touch.clientY
  };
}

function handleTouchStart(e) {
  e.preventDefault();
  if(!imgLoaded) return;
  const {x, y} = getTouchPos(e);
  if([...document.elementsFromPoint(x, y)].some(el => el.className && el.className.includes('point'))) return;
  draggingMap = true;
  startPan = { x, y, px: panX, py: panY };
}
function handleTouchMove(e) {
  if(!draggingMap) return;
  e.preventDefault();
  const {x, y} = getTouchPos(e);
  panX = startPan.px + (x - startPan.x);
  panY = startPan.py + (y - startPan.y);
  draw(); updateDOM();
}
function handleTouchEnd(e) {
  draggingMap = false;
  e.preventDefault();
}

cvs.ondblclick = e => {
    if (!imgLoaded) return;
    if ([...document.elementsFromPoint(e.clientX, e.clientY)]
        .some(el => el.classList && el.classList.contains("point"))) return;
    if (document.documentElement.classList.contains("simple-mode")) {
        e.preventDefault(); e.stopPropagation();
        const rect = cvs.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        addRoutePoint(x, y);
        updateNumbers(); draw();
    } else {
        openTypeMenuAt(e.clientX, e.clientY);
    }
};

let lastTap = 0;
let lastTapPos = null;

cvs.addEventListener('touchend', function(e){
    
    const {x, y} = getTouchPos(e);

    
    if([...document.elementsFromPoint(x, y)].some(el => el.className && el.className.includes('point'))) return;

    const now = Date.now();
    if(lastTap && lastTapPos) {
        const dx = Math.abs(x - lastTapPos.x);
        const dy = Math.abs(y - lastTapPos.y);
        const dist = Math.sqrt(dx*dx + dy*dy);
        if((now - lastTap < 400) && dist < 15) { 
            openTypeMenuAt(x, y);
            lastTap = 0; lastTapPos = null; 
            return;
        }
    }
    lastTap = now;
    lastTapPos = {x, y};
}, {passive:false});

function openTypeMenuAt(clientX, clientY) {
    showTypeSelect(clientX, clientY, type => {
        const r = imgRect();
        const nx = (clientX - r.x)/r.w, ny = (clientY - r.y)/r.h;
        createPoint({x:nx, y:ny, label:'', note:'', ptype:type});
        updateNumbers(); draw();
    });
}

function showTypeSelect(x, y, cb) {
  let menu = document.createElement('div');
  menu.className = 'menu';
  menu.style.left = x + 'px';
  menu.style.top  = y + 'px';

  
  menu.innerHTML = '<b><span data-i18n-key="CHOOSE_TYPE">'
                 + uiTranslations['CHOOSE_TYPE'][uiLocale]
                 + '</span></b>';

  
  
  ['route','place','char','event','item'].forEach(type => {
    const meta = translations[uiLocale].pointTypes[type];
    const key  = 'PT_' + type.toUpperCase();

    let btn = document.createElement('button');
    btn.setAttribute('data-i18n-key', key);

    
    if (meta.icon) {
      const ico = document.createElement('span');
      ico.className = 'icon';
      ico.textContent = meta.icon;
      btn.appendChild(ico);
    }

    
    btn.appendChild(document.createTextNode(meta.name));

    btn.onclick = () => { cb(type); menu.remove(); };
    menu.appendChild(btn);
  });

  document.body.appendChild(menu);

  
  setTimeout(() => {
    document.addEventListener('pointerdown', function h(ev) {
      if (!menu.contains(ev.target)) {
        menu.remove();
        document.removeEventListener('pointerdown', h);
      }
    });
  });
}

let menu=null;

function showMenu(x,y,p){
  menu && menu.remove();
  menu = document.createElement('div');
  menu.className = 'menu';
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  const meta = getTypeMeta(p.ptype || 'route');
  menu.innerHTML = `
    <button id="e">${uiTranslations['CTX_CHAPTER_EDIT'][uiLocale]}</button>
    <button id="n">${uiTranslations['CTX_NOTE_EDIT'][uiLocale]}</button>
    <button id="toggleNote"></button>
    <button id="typ">${uiTranslations['CTX_CHANGE_TYPE'][uiLocale]}</button>
    <button id="dauer">${uiTranslations['CTX_SET_DURATION'][uiLocale]}</button>
    <button id="d">${uiTranslations['CTX_DELETE'][uiLocale]}</button>
  `;
  document.body.appendChild(menu);

  const btnToggle = menu.querySelector('#toggleNote');
  btnToggle.textContent = (p.noteEl && p.noteEl.style.display === 'block')
    ? uiTranslations['CTX_HIDE_NOTE'][uiLocale]
    : uiTranslations['CTX_SHOW_NOTE'][uiLocale];

const helperBtn = document.createElement('button');
helperBtn.id = 'helper';
helperBtn.setAttribute('data-i18n-key', p.helper ? 'CTX_HELPER_OFF' : 'CTX_HELPER_ON');
helperBtn.textContent = uiTranslations[p.helper ? 'CTX_HELPER_OFF' : 'CTX_HELPER_ON'][uiLocale];
menu.insertBefore(helperBtn, menu.querySelector('#typ'));

btnToggle.onclick = () => {
  if (p.noteEl && p.noteEl.style.display === 'block') {
    p.noteEl.style.display = 'none';
  } else {
    if (!p.noteEl) {
      p.noteEl = document.createElement('div');
      p.noteEl.className = 'label note';
      p.el.appendChild(p.noteEl);
    }
    p.noteEl.textContent = p.note || '';
    p.noteEl.style.display = (showNotes && (p.note || p.noteEl.textContent)) ? 'block' : 'none';
  }
  setStackVars(p);
  menu.remove();
};
  
  menu.querySelector('#e').onclick = () => {
    const v = prompt(meta.label, p.label);
    if (v !== null) {
      push(); p.label = v; p.lbl.textContent = v; updateVis();
    }
    menu.remove();
  };

  
menu.querySelector('#n').onclick = () => {
  const v = prompt('Note', p.note || '');
  if (v !== null) {
    push();
    p.note = v;

    if (!p.noteEl) {
      p.noteEl = document.createElement('div');
      p.noteEl.className = 'label note';
    }
    p.el.appendChild(p.noteEl);
    p.noteEl.textContent = p.note;
    p.noteEl.style.display = (showNotes && p.note) ? 'block' : 'none';

    ensureChildren(p);
    setStackVars(p);
  }
  menu.remove();
};

menu.querySelector('#dauer').onclick = () => {
  const v = prompt('Duration (e.g., 3 days)', p.dauer || '');
  if (v !== null) {
    push();
    p.dauer = v;

    if (!p.dauerEl) {
      p.dauerEl = document.createElement('div');
      p.dauerEl.className = 'dauer';
    }
    p.el.appendChild(p.dauerEl);                 // <- an den Punkt h√§ngen
    p.dauerEl.textContent = p.dauer;
    p.dauerEl.style.display = (showDauer && p.dauer) ? 'block' : 'none';

    ensureChildren(p);
    setStackVars(p);
  }
  menu.remove();
};

  
  
  menu.querySelector('#helper').onclick = () => {
    push();
    p.helper = !p.helper;
    p.el && p.el.classList && p.el.classList.toggle('helper', p.helper);
    updateNumbers();
    draw();
    menu.remove();
  };

  // Punkttyp √§ndern
const btnType = menu.querySelector('#typ');
if (btnType) {
  btnType.onclick = () => {
    // √ñffnet das bekannte Type-Popup; Callback liefert den neuen Typ "t"
    showTypeSelect(x, y, (t) => {
      push();
      // Modell aktualisieren
      p.ptype = t;

      // Icon aktualisieren (Route hat kein Icon)
      p.icon.textContent = (t !== 'route') ? getIcon(t) : '';

      // Nummerierung/Sichtbarkeit/Redraw aktualisieren
      updateNumbers();
      updateVis();
      draw();

      // Men√º schlie√üen
      menu.remove();
    });
  };
}

menu.querySelector('#d').onclick = () => {
    if (confirm('Delete point?')) {
      push();
      const idx = points.indexOf(p);
      if (idx !== -1) {
        const removed = points.splice(idx,1)[0];
        removed.el.remove();
        removed.noteEl && removed.noteEl.remove();
        removed.dauerEl && removed.dauerEl.remove();
        updateNumbers(); draw();
      }
    }
    menu.remove();
  };
}

document.body.addEventListener('pointerdown',e=>{ if(menu && !menu.contains(e.target)) menu.remove(); });

document.getElementById('exportMd').onclick = () => {
    function distance(p1, p2) {
        const dx = (p1.x || 0) - (p2.x || 0);
        const dy = (p1.y || 0) - (p2.y || 0);
        return Math.sqrt(dx * dx + dy * dy);
    }

    let routePoints = points.filter(p => (p.ptype || 'route') === 'route');
    let otherPoints = points.filter(p => (p.ptype || 'route') !== 'route');

    
    routePoints.sort((a, b) => {
        if (a.pathId !== b.pathId) return 0;
        return points.indexOf(a) - points.indexOf(b);
    });

    
    let step=1; routePoints.forEach(p=>{ if(p.helper){ p.route_step=''; } else { p.route_step=step++; } });
let bucketMap = new Map();
    routePoints.forEach(p => bucketMap.set(p, []));

    otherPoints.forEach(p => {
        let nearest = routePoints[0];
        let minDist = distance(p, nearest);
        for (let i = 1; i < routePoints.length; i++) {
            let d = distance(p, routePoints[i]);
            if (d < minDist) {
                minDist = d;
                nearest = routePoints[i];
            }
        }
        bucketMap.get(nearest).push(p);
    });

    
let md =  '| Typ | Label | Notiz | X | Y | Route-Step | Dauer |' + '\n'
          + '|---|---|---|---|---|---|---|' + '\n';

  
  routePoints.forEach(p => {
    const typeName = getTypeMeta(p.ptype||'route').name;
    md +=  '| ' + typeName
        + ' | ' + (p.label  || '').replace(/\|/g,'/')
        + ' | ' + (p.note   || '').replace(/\|/g,'/')
        + ' | ' + (p.x||0).toFixed(4)
        + ' | ' + (p.y||0).toFixed(4)
        + ' | ' + p.route_step
        + ' | ' + (p.dauer || '')
        + ' |' + '\n';
        const others = bucketMap.get(p) || [];
others.forEach(op => {
  const opName = getTypeMeta(op.ptype || 'ort').name;
  md += '| ' + opName
      + ' | ' + (op.label || '').replace(/\|/g, '/')
      + ' | ' + (op.note  || '').replace(/\|/g, '/')
      + ' | ' + (op.x || 0).toFixed(4)
      + ' | ' + (op.y || 0).toFixed(4)
      + ' | ' + (op.route_step || '')
      + ' | ' + (op.dauer || '')
      + ' |'
      + '\n';
});
    });

    const blob = new Blob([md], {type:'text/markdown'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0].replace(/-/g, '');
    a.download = `PlotMap_${dateStr}_${mdExportCount++}.md`;
    a.click();
};

document.getElementById('importMd').onclick = () => {
  let inp = document.createElement('input');
  inp.type = 'file'; inp.accept = '.md,text/markdown';
  inp.onchange = e => {
    const file = inp.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(ev) {
      let text = ev.target.result;
      
      let lines = text.split('\n').filter(l => l.trim() && !l.startsWith('|---'));
      let newPoints = [];
      
      for (let i = 1; i < lines.length; i++) {
        let cols = lines[i].split('|').map(x => x.trim());
        
        if (cols.length < 8) continue;
        let [ , typ, label, note, xs, ys, step, dauer ] = cols;
        let meta = POINT_TYPES.find(t => t.name === typ) || POINT_TYPES[0];
        newPoints.push({
          ptype: meta.type,
          label,
          note,
          x: parseFloat(xs),
          y: parseFloat(ys),
          route_step: (/^\d+$/.test(step) ? parseInt(step,10) : ''),
          dauer: dauer || '',
          helper: (!/^\d+$/.test(step))
        });
      }
      if (newPoints.length) {
        push();
        clearDOM();
        points.length = 0;
        newPoints.forEach(d => createPoint(d, true));
        updateNumbers();
        draw();
        updateDOM();

      }
    };
    reader.readAsText(file);
  };
  inp.click();
};

document.getElementById('exportImg').onclick = () => {
    
    midEls.forEach(m=>m.style.display='none');
    document.querySelectorAll('.dauer').forEach(d=>d.style.display='none');
    
    draw();

    
    const r = imgRect();
    ctx.save();

    
    if (showLines) {
        const routePts = points.filter(p => (p.ptype||'route')==='route' && isVisibleType('route'));
        if (routePts.length > 1) {
            ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath();
            routePts.forEach((p,i)=> {
              const x = r.x + p.x*r.w, y = r.y + p.y*r.h;
              i>0 ? ctx.lineTo(x,y) : ctx.moveTo(x,y);
            });
            ctx.stroke();
            ctx.strokeStyle = 'red'; ctx.lineWidth = 2; ctx.beginPath();
            routePts.forEach((p,i)=> {
              const x = r.x + p.x*r.w, y = r.y + p.y*r.h;
              i>0 ? ctx.lineTo(x,y) : ctx.moveTo(x,y);
            });
            ctx.stroke();
        }
    }

    
    let cnt = 1;
    points.forEach(p => {
        if (!isVisibleType(p.ptype||'route')) return;
        const x = r.x + p.x*r.w, y = r.y + p.y*r.h;

        
        ctx.beginPath();
        ctx.arc(x,y,16,0,2*Math.PI);
        ctx.fillStyle = 'rgba(255,255,255,0.96)'; ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,0.95)'; ctx.stroke();

        
        ctx.fillStyle = '#000';
        ctx.font = 'bold 16px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        if ((p.ptype||'route') === 'route') {
            ctx.fillText(kapitelMode ? (kapitelStartNum+cnt-1) : cnt, x, y);
            cnt++;
        } else {
            ctx.font = '22px sans-serif';
            ctx.fillText(getIcon(p.ptype), x, y+1);
        }

        
        if (p.label && showLabels) {
            ctx.font = '11px sans-serif';
            const w = ctx.measureText(p.label).width;
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(x - w/2 - 4, y + 18, w + 8, 18);
            ctx.fillStyle = '#fff'; ctx.textBaseline = 'middle';
            ctx.fillText(p.label, x, y + 27);
        }

        
        if (showNotes && p.note) {
            ctx.font = '12px sans-serif';
            const noteY = y + 46;
            const w = ctx.measureText(p.note).width;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x - w/2 - 4, noteY - 9, w + 8, 18);
            ctx.fillStyle = '#fff';
            ctx.fillText(p.note, x, noteY);
        }
    });

    ctx.restore();

    
    requestAnimationFrame(() => {
      cvs.toBlob(blob => {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        const dateStr = new Date().toISOString().slice(0,10).replace(/-/g,'');
        link.download = `PlotMap_${dateStr}_${imgExportCount++}.png`;
        link.click();
        URL.revokeObjectURL(link.href);
        
        midEls.forEach(m=>m.style.display='flex');
        document.querySelectorAll('.dauer').forEach(d=>d.style.display='block');
        draw(); updateDOM();
      }, 'image/png');
    });
};
resize();
function ensureChildren(p){
  if(p.noteEl && p.noteEl.parentNode !== p.el){ p.el.appendChild(p.noteEl); }
  if(p.dauerEl && p.dauerEl.parentNode !== p.el){ p.el.appendChild(p.dauerEl); }
}
function setStackVars(p){
  const lblH  = p.lbl ? p.lbl.offsetHeight : 0;
  const noteVisible = (p.noteEl && p.noteEl.style.display !== 'none');
  const noteH = noteVisible ? p.noteEl.offsetHeight : 0;
  p.el.style.setProperty('--lbl-h',  lblH + 'px');
  p.el.style.setProperty('--note-h', noteH + 'px');
}
</script>
<script>const uiTranslations = {
  "TOGGLE_MODE_1":     { "en": "Focus Mode",    "de": "Fokus-Modus" },
  "CHAPTER_NUMBERING_2":{ "en": "Chapter Numbering", "de": "Kapitel-Nummerierung" },
  "CHAPTER_3":         { "en": "Chapter",       "de": "Kapitel" },
  "SHOW_NOTES_4":      { "en": "Show Notes",    "de": "Notizen anzeigen" },
  "LINES_5":           { "en": "Lines",         "de": "Linien" },
  "EDIT_BUTTONS_6":    { "en": "Edit-Buttons",  "de": "Edit-Buttons" },
  "POINT_TYPES_FILTER_7":{ "en": "Point Types Filter", "de": "Punktarten Filter" },
  "ROUTE_8":           { "en": "Route",         "de": "Route" },
  "PLACE_9":           { "en": "Place",         "de": "Ort" },
  "CHARACTER_10":      { "en": "Character",     "de": "Charakter" },
  "EVENT_11":          { "en": "Event",         "de": "Event" },
  "ITEM_12":           { "en": "Item",          "de": "Item" },
  "_SHOW_DURATION_13": { "en": "‚åõ Show Duration","de": "‚åõ Dauer anzeigen" },
  "ZOOM_14":           { "en": "Zoom",          "de": "Zoom" },
  "OPACITY_15":        { "en": "Opacity",       "de": "Deckkraft" },
  "_UNDO_16":          { "en": "‚Ü∫ Undo",        "de": "‚Ü∫ R√ºckg√§ngig" },
  "_REDO_17":          { "en": "‚Üª Redo",        "de": "‚Üª Wiederholen" },
  "EXPORT_MD_18":      { "en": "Export MD",     "de": "Export MD" },
  "IMPORT_MD_19":      { "en": "Import MD",     "de": "Import MD" },
  "PNG_20":            { "en": "PNG",           "de": "PNG" },
  "CLEAR_ALL_21":      { "en": "Clear All",     "de": "Alle l√∂schen" },
  "LANG_TOGGLE":       { "en": "DE",            "de": "EN" },
  "CHOOSE_TYPE":       { "en": "Choose type:",  "de": "Typ w√§hlen:" },
  "CTX_CHAPTER_EDIT":  { "en": "Chapter Edit",  "de": "Kapitel bearbeiten" },
  "CTX_NOTE_EDIT":     { "en": "Note Edit",     "de": "Notiz bearbeiten" },
  "CTX_SHOW_NOTE":     { "en": "Show Note",     "de": "Notiz anzeigen" },
  "CTX_HIDE_NOTE":     { "en": "Hide Note",     "de": "Notiz verbergen" },
  "CTX_CHANGE_TYPE":   { "en": "Change Point Type","de": "Punkttyp √§ndern" },
  "CTX_SET_DURATION":  { "en": "‚åõ Set Duration","de": "‚åõ Dauer setzen" },
  "CTX_HELPER_ON":  { "en": "Skip number (helper point)", "de": "Nummer auslassen (Hilfspunkt)" },
  "CTX_HELPER_OFF": { "en": "Show number",                 "de": "Nummer anzeigen" },
  "CTX_DELETE":        { "en": "Delete",        "de": "L√∂schen" },
  "TOGGLE_MODE_2":     { "en": "Story Mode",    "de": "Story-Modus" },
  "FOCUS_MODE":        { "en": "Focus Mode",    "de": "Fokus-Modus" },
  "STORY_MODE":        { "en": "Story Mode",    "de": "Story-Modus" },
  "RELOAD_WARN": {
  "en": "Warning: Reloading will clear the canvas ‚Äì all points will be lost. Reload anyway?",
  "de": "Achtung: Beim Neuladen wird die Canvas geleert ‚Äì alle Punkte sind weg. Trotzdem neu laden?"
}
};

let uiLocale = new URLSearchParams(location.search).get('lang') ||
               (navigator.language.startsWith('de') ? 'de' : 'en');

function applyUI() {
  document.documentElement.lang = uiLocale;
  document.querySelectorAll('[data-i18n-key]').forEach(el => {
    const key = el.getAttribute('data-i18n-key');
    if (uiTranslations[key] && uiTranslations[key][uiLocale]) {
      el.textContent = uiTranslations[key][uiLocale];
    }
  });
}

window.addEventListener('DOMContentLoaded', () => {
  
  applyUI();

  
  const langBtn = document.getElementById('langToggle');
  langBtn.addEventListener('click', () => {
    uiLocale = uiLocale === 'en' ? 'de' : 'en';
    applyUI();
    history.replaceState(null, '', '?lang=' + uiLocale);
  });

  
  let simpleMode = localStorage.getItem('mode') === 'base';
  document.documentElement.classList.toggle('simple-mode', simpleMode);
  const modeBtn = document.getElementById('modeToggle');
  if (modeBtn) {
    let span = modeBtn.querySelector('span');
    if (!span) {
      span = document.createElement('span');
      modeBtn.textContent = '';
      modeBtn.appendChild(span);
    }
    span.setAttribute('data-i18n-key',
      simpleMode ? 'TOGGLE_MODE_2' : 'TOGGLE_MODE_1'

    );
    applyUI();

    modeBtn.addEventListener('click', () => {
      simpleMode = !simpleMode;
      document.documentElement.classList.toggle('simple-mode', simpleMode);
      localStorage.setItem('mode', simpleMode ? 'base' : 'plus');
      span.setAttribute('data-i18n-key',
        simpleMode ? 'TOGGLE_MODE_2' : 'TOGGLE_MODE_1'

      );
      applyUI();
      updateVis();
      draw();
      updateDOM();
    });
  }
});
</script><script id="pm-fontscale-js">
(function(){
  function ensureI18n(){
    window.uiTranslations = window.uiTranslations || {};
    if(!uiTranslations['UI_FONT_SCALE']){
      uiTranslations['UI_FONT_SCALE'] = { de:'Schriftgr√∂√üe', en:'Font size' };
    }
  }

function addSlider(){
  const ui = document.getElementById('ui');
  if(!ui) return;
  if(document.getElementById('fontScale')) return; // schon da

  const lbl = document.createElement('label');
  lbl.setAttribute('for','fontScale');
  lbl.setAttribute('data-i18n-key','UI_FONT_SCALE');

  const input = document.createElement('input');
  input.id = 'fontScale';
  input.type = 'range';
  input.min = '50';
  input.max = '200';
  input.value = '100';

  const span = document.createElement('span');
  span.id = 'fontScaleValue';
  span.textContent = '100%';

  // i18n Text setzen
  try {
    const key = 'UI_FONT_SCALE';
    const loc = (window.uiLocale || 'en');
    lbl.textContent = (uiTranslations[key] && uiTranslations[key][loc]) ? uiTranslations[key][loc] : 'Font size';
  } catch(e){ lbl.textContent = 'Font size'; }

  // etwas Abstand rechts neben dem Zoom-Slider
  lbl.style.marginLeft   = '20px';
  input.style.marginLeft = '6px';
  span.style.marginLeft  = '6px';

  // Statt ans Ende: direkt hinter #zoom einf√ºgen (vor dem <br/> danach)
  const zoomInput = document.getElementById('zoom');
  if (zoomInput && zoomInput.parentNode === ui) {
    const afterZoomBr = zoomInput.nextSibling; // das <br/> nach Zoom
    ui.insertBefore(lbl,   afterZoomBr);
    ui.insertBefore(input, afterZoomBr);
    ui.insertBefore(span,  afterZoomBr);
  } else {
    // Fallback: ans Ende, falls Struktur anders ist
    ui.appendChild(lbl);
    ui.appendChild(input);
    ui.appendChild(span);
  }

  // Handler
  input.addEventListener('input', function(e){
    const scale = (parseInt(e.target.value,10) || 100) / 100;
    document.documentElement.style.setProperty('--font-scale', String(scale));
    span.textContent = e.target.value + '%';

    // Reflow f√ºrs absvar-Stacking
    try{
      if(Array.isArray(window.points)){
        points.forEach(function(p){
          if(typeof window.ensureChildren === 'function') ensureChildren(p);
          if(typeof window.setStackVars   === 'function') setStackVars(p);
        });
      }
      if(typeof window.updateDOM === 'function') updateDOM();
      if(typeof window.draw      === 'function') draw();
    }catch(_){}
  });
}

  

  function init(){
    ensureI18n();
    addSlider();
    }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  }else{
    init();
  }
})();


// System-Dialog immer zeigen (F5, Button, Tab schlie√üen, Pull-to-Refresh)
window.addEventListener('beforeunload', function (e) {
  e.preventDefault();
  e.returnValue = ''; // Standarddialog
});

// Zus√§tzlicher Klartext bei Tastatur-Reload (F5 / Ctrl+R / Cmd+R)
document.addEventListener('keydown', function (e) {
  const isReload = (e.key === 'F5') || ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'r');
  if (!isReload) return;
  e.preventDefault();

  // Sprache direkt aus <html lang> (wird in applyUI gesetzt)
  const loc = document.documentElement.lang || 'en';
  const t = (uiTranslations.RELOAD_WARN && uiTranslations.RELOAD_WARN[loc])
              ? uiTranslations.RELOAD_WARN[loc]
              : (uiTranslations.RELOAD_WARN ? uiTranslations.RELOAD_WARN.en : 'Reload?');

  if (confirm(t)) {
    // Nutzer best√§tigt: normal neu laden
    location.reload();
  }
});
</script>
</body></html>